(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{240:function(n,e,t){"use strict";t.r(e);var a=t(0),r=Object(a.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("p",[n._v("√# hui-tools\n标签（空格分隔）： hui cli")]),n._v(" "),t("hr"),n._v(" "),t("h3",{attrs:{id:"起因"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#起因"}},[n._v("#")]),n._v(" 起因")]),n._v(" "),t("p",[n._v("在实际的开发过程中，从零开始建立项目的结构是一件让人头疼的事情，所以各种各样的脚手架工具应运而生。yoeman，express-generator和vue-cli便是当中之一。它们功能丰富，但最核心的功能都是能够快速搭建一个完整的项目的结构，开发者只需要在生成的项目结构的基础上进行开发即可，非常简单高效。")]),n._v(" "),t("h3",{attrs:{id:"原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[n._v("#")]),n._v(" 原理")]),n._v(" "),t("p",[n._v("yoeman搭建项目需要提供yoeman-generator。yoeman-generator本质上就是一个具备完整文件结构的项目样板，用户需要手动地把这些generator下载到本地，然后yoeman就会根据这些generator自动生成各种不同的项目。")]),n._v(" "),t("p",[n._v("vue-cli提供了相当丰富的选项和设定功能，但是其本质也是从远程仓库把不同的模版拉取到本地，而并非是什么“本地生成”的黑科技。")]),n._v(" "),t("p",[n._v("这样看来，思路也就有了——首先建立不同的样板项目，然后脚手架根据用户的指令引用样板项目生成实际项目。样板项目可以内置在脚手架当中，也可以部署在远程仓库。为了更广的适用范围，hui-tools采用的是第二种方式。")]),n._v(" "),t("h3",{attrs:{id:"选型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#选型"}},[n._v("#")]),n._v(" 选型")]),n._v(" "),t("p",[n._v("node.js：整个脚手架工具的根本组成部分，推荐使用最新的版本。")]),n._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/tj/commander.js",target:"_blank",rel:"noopener noreferrer"}},[n._v("commander.js"),t("OutboundLink")],1),n._v("：组织和处理命令行的输入。"),t("a",{attrs:{href:"https://blog.csdn.net/qq_40129176/article/details/80816853",target:"_blank",rel:"noopener noreferrer"}},[n._v("中文介绍地址"),t("OutboundLink")],1)]),n._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/sboudrias/Inquirer.js",target:"_blank",rel:"noopener noreferrer"}},[n._v("Inquirer.js"),t("OutboundLink")],1),n._v(" :为NodeJs做一个可嵌入式的美观的命令行界面 "),t("a",{attrs:{href:"https://www.jianshu.com/p/db8294cfa2f7",target:"_blank",rel:"noopener noreferrer"}},[n._v("中文学习地址"),t("OutboundLink")],1)]),n._v(" "),t("p",[n._v("chalk:改变输出文字的颜色")]),n._v(" "),t("p",[n._v("ora:小图标（loading、succeed、warn等）")]),n._v(" "),t("h3",{attrs:{id:"整体架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#整体架构"}},[n._v("#")]),n._v(" 整体架构")]),n._v(" "),t("p",[n._v("整体架构，看图：")]),n._v(" "),t("p",[t("img",{attrs:{src:"https://image-static.segmentfault.com/386/987/3869878572-57a5535c106ab_articlex",alt:"此处输入图片的描述"}}),n._v("\n首先明白模版的概念。一个模版就是一个项目的样板，包含项目的完整结构和信息。\n模版的信息都存放在一个叫做templates.json的文件当中。\n用户可以通过命令行对templates.json进行添加、删除、罗列的操作。\n通过选择不同的模版，hui会自动从远程仓库把相应的模板拉取到本地，完成项目的搭建。")]),n._v(" "),t("p",[n._v("最终整个脚手架的文件结构如下：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("|__ bin\n    |__ hui\n  |__ command\n    |__ add.js\n    |__ delete.js\n    |__ init.js\n    |__ list.js\n  |__ node_modules\n  |__ package.json\n  |__ templates.json\n")])])]),t("h2",{attrs:{id:"入口文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#入口文件"}},[n._v("#")]),n._v(" 入口文件")]),n._v(" "),t("p",[n._v("首先建立项目，在package.json里面写入依赖并执行npm install")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('"dependencies": {\n    "chalk": "^1.1.3",\n    "commander": "^2.9.0",\n    "download-git-repo": "^1.0.0",\n    "handlebars": "^4.0.8",\n    "inquirer": "^3.0.6",\n    "ora": "^1.2.0"\n  }\n')])])]),t("p",[n._v("在根目录下建立\\bin文件夹，在里面建立一个无后缀名的hui文件。这个bin\\hui文件是整个脚手架的入口文件，所以我们首先对它进行编写。")]),n._v(" "),t("p",[n._v("首先是一些初始化的代码：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("#!/usr/bin/env node --harmony\n'use strict'\n // 定义脚手架的文件路径\nprocess.env.NODE_PATH = __dirname + '/../node_modules/'\n\nconst program = require('commander')\n\n // 定义当前版本\nprogram\n    .version(require('../package').version )\n\n// 定义使用方法\nprogram\n    .usage('<command>')\n前文的架构图中可以知道，脚手架支持用户输入4种不同的命令。现在我们来写处理这4种命令的方法：\n    program\n    .command('list')\n    .description('List all the templates')\n    .alias('l')\n    .action(() => {\n        require('../command/list')()\n    })\n\nprogram\n    .command('init')\n    .description('Generate a new project')\n  .alias('i')\n  .action(() => {\n    require('../command/init')()\n  })\n\nprogram\n    .command('delete')\n    .description('Delete a template')\n    .alias('d')\n    .action(() => {\n        require('../command/delete')()\n    })\n")])])]),t("p",[n._v("使用node运行这个文件，看到输出如下，证明入口文件已经编写完成了。\nUsage: hui "),t("command")],1),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("Commands:\n\n    add|a      新增模板\n    list|l     展示所有模板\n    init|i     初始化模板\n    delete|d   删除模板\n")])])]),t("h2",{attrs:{id:"处理用户输入"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#处理用户输入"}},[n._v("#")]),n._v(" 处理用户输入")]),n._v(" "),t("p",[n._v("在项目根目录下建立\\command文件夹，专门用来存放命令处理文件。\n在根目录下建立templates.json文件并写入如下内容，用来存放模版信息：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('{"tpl":{}}\n')])])]),t("h2",{attrs:{id:"添加模板"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#添加模板"}},[n._v("#")]),n._v(" 添加模板")]),n._v(" "),t("p",[n._v("进入\\command并新建add.js文件")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("const { prompt } = require('inquirer')\nconst { writeFile } = require('fs')\nconst { listTable } = require(`${__dirname}/../utils`)\n\nlet tplList = require(`${__dirname}/../templates`)\n\nconst question = [\n  {\n    type: 'input',\n    name: 'name',\n    message: '给你的模板选个名字吧:',\n    validate (val) {\n      if (tplList[val]) {\n        return '重名了!'\n      } else if (val === '') {\n        return '名字是必须的!'\n      } else {\n        return true\n      }\n    }\n  },\n  {\n    type: 'input',\n    name: 'place',\n    message: '模板拥有者:',\n    validate (val) {\n      if (val !== '') {\n        return true\n      }\n      return '必填项!'\n    }\n  },\n  {\n    type: 'input',\n    name: 'branch',\n    message: '模板分支(git仓库):',\n    default: 'master'\n  }\n]\n\nmodule.exports = prompt(question).then(({ name, place, branch }) => {\n  tplList[name] = {}\n  tplList[name]['owner/name'] = place\n  tplList[name]['branch'] = branch\n// 把模板信息写入templates.json\n  writeFile(`${__dirname}/../templates.json`, JSON.stringify(tplList), 'utf-8', (err) => {\n    if (err) {\n      console.log(err)\n    }\n    listTable(tplList, '模板创立成功!')\n  })\n})\n")])])]),t("h2",{attrs:{id:"删除模板"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#删除模板"}},[n._v("#")]),n._v(" 删除模板")]),n._v(" "),t("p",[n._v("同样的，在\\command文件夹下建立delete.js文件")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("const { prompt } = require('inquirer')\nconst { writeFile } = require('fs')\nconst { listTable } = require(`${__dirname}/../utils`)\n\nlet tplList = require(`${__dirname}/../templates`)\n\nconst question = [\n  {\n    type: 'input',\n    name: 'name',\n    message: '你想删除哪个模板?:',\n    validate (val) {\n      if (tplList[val]) {\n        return true\n      } else if (val === '') {\n        return '请输入模板名!'\n      } else if (!tplList[val]) {\n        return '该模板已删除.'\n      }\n    }\n  }\n]\n\nmodule.exports = prompt(question).then(({ name }) => {\n  delete tplList[name]\n\n  writeFile(`${__dirname}/../templates.json`, JSON.stringify(tplList), 'utf-8', (err) => {\n    if (err) {\n      console.log(err)\n    }\n    listTable(tplList, '模板删除成功!')\n  })\n})\n")])])]),t("h2",{attrs:{id:"罗列模板"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#罗列模板"}},[n._v("#")]),n._v(" 罗列模板")]),n._v(" "),t("p",[n._v("\\command文件夹下建立list.js文件")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("const { listTable } = require(`${__dirname}/../utils`)\n\nlet tplList = require(`${__dirname}/../templates`)\n\nmodule.exports = listTable(tplList)\n")])])]),t("h2",{attrs:{id:"构建项目"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构建项目"}},[n._v("#")]),n._v(" 构建项目")]),n._v(" "),t("p",[n._v("现在来到我们最重要的部分——构建项目。同样的，在\\command目录下新建一个叫做init.js的文件")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("const { prompt } = require('inquirer')\nconst { writeFile } = require('fs')\nconst { listTable } = require(`${__dirname}/../utils`)\nconst exec = require('child_process').exec\nconst { resolve } = require('path')\nconst chalk = require('chalk')\nconst download = require('download-git-repo')\nconst ora = require('ora')\n\nlet tplList = require(`${__dirname}/../templates`)\n\nconst question = [\n  {\n    type: 'input',\n    name: 'name',\n    message: '模板名:',\n    validate (val) {\n      if (tplList[val]) {\n        return true\n      } else if (val === '') {\n        return '模板名是必填!'\n      } else if (!tplList[val]) {\n        return '该模板不存在.'\n      }\n    }\n  },\n  {\n    type: 'input',\n    name: 'project',\n    message: '项目名:',\n    validate (val) {\n      if (val !== '') {\n        return true\n      }\n      return '项目名是必须的!'\n    }\n  }\n  // {\n  //   type: 'input',\n  //   name: 'place',\n  //   message: '选择路径创建项目:',\n  //   default: './'\n  // }\n]\n\nmodule.exports = prompt(question).then(({ name, project, place }) => {\n  const gitPlace = tplList[name]['owner/name']\n  const gitBranch = tplList[name]['branch']\n  const spinner = ora('模板下载中...')\n\n  spinner.start()\n  // git命令，远程拉取项目并自定义项目名\n  let cmdStr = `git clone ${gitBranch} ${project} && cd ${project}`\n  exec(cmdStr, (error, stdout, stderr) => {\n    if (error) {\n      console.log(error)\n      process.exit()\n    }\n    spinner.stop()\n    console.log(chalk.green('新项目初始化成功!'))\n    process.exit()\n  })\n})\n")])])]),t("h2",{attrs:{id:"全局使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#全局使用"}},[n._v("#")]),n._v(" 全局使用")]),n._v(" "),t("p",[n._v("为了可以全局使用，我们需要在package.json里面设置一下：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('"bin": {\n    "hui": "bin/hui"\n  },\n')])])]),t("p",[n._v("本地调试的时候，在根目录下执行")]),n._v(" "),t("p",[n._v("npm link\n即可把hui命令绑定到全局，以后就可以直接以hui作为命令开头而无需敲入长长的node hui之类的命令了。")]),n._v(" "),t("h2",{attrs:{id:"效果展示"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#效果展示"}},[n._v("#")]),n._v(" 效果展示")])])}),[],!1,null,null,null);e.default=r.exports}}]);