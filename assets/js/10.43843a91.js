(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{212:function(e,t,n){"use strict";n.r(t);var a=n(0),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"vue的mvvm原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vue的mvvm原理"}},[e._v("#")]),e._v(" vue的mvvm原理")]),e._v(" "),n("h2",{attrs:{id:"简述版"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#简述版"}},[e._v("#")]),e._v(" 简述版")]),e._v(" "),n("p",[e._v("vue是采用数据劫持配合发布者-订阅者模式，通过object.defineProperty来劫持各个属性的set和get，在数据变动时，发布信息给依赖收集器，去通知观察者，做出对应的回调函数，区更新视图。\nMvvm作为绑定的入口，整合observe，compile和watcher三者，通过observe来监听model的数据变化，通过compile来解析编译模板指令，最终利用watcher搭起observe和compile的桥梁，做到双向绑定。")]),e._v(" "),n("h2",{attrs:{id:"实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[e._v("#")]),e._v(" 实现")]),e._v(" "),n("p",[e._v("Vue 内部使用了 Object.defineProperty() 来实现数据响应式，通过这个函数可以监听到 set 和 get 的事件。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("function observe(obj) {\n  // 判断类型\n  if (!obj || typeof obj !== 'object') {\n    return\n  }\n  Object.keys(obj).forEach(key => {\n    defineReactive(obj, key, obj[key])\n  })\n}\n\nfunction defineReactive(obj, key, val) {\n  // 递归子属性\n  observe(val)\n  let dp = new Dep()\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter() {\n      console.log('get value')\n      // 将 Watcher 添加到订阅\n      if (Dep.target) {\n        dp.addSub(Dep.target)\n      }\n      return val\n    },\n    set: function reactiveSetter(newVal) {\n      console.log('change value')\n      val = newVal\n      // 执行 watcher 的 update 方法\n      dp.notify()\n    }\n  })\n")])])]),n("p",[e._v("依赖收集，才能在属性更新的时候派发更新，所以接下来我们需要先触发依赖收集。Dep一个属性只有一个，用来存放watcher")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("// 通过 Dep 解耦属性的依赖和更新操作\nclass Dep {\n  constructor() {\n    this.subs = []\n  }\n  // 添加依赖\n  addSub(sub) {\n    this.subs.push(sub)\n  }\n  // 更新\n  notify() {\n    this.subs.forEach(sub => {\n      sub.update()\n    })\n  }\n}\n// 全局属性，通过该属性配置 Watcher\nDep.target = null\n")])])]),n("p",[e._v("当需要依赖收集的时候调用 addSub，当需要派发更新的时候调用 notify。\nvue在组件挂载时，会先对所有需要的属性调用 Object.defineProperty()，然后实例化 Watcher，传入组件更新的回调。在实例化过程中，会对模板中的属性进行求值，触发依赖收集。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("class Watcher {\n  constructor(obj, key, cb) {\n    // 将 Dep.target 指向自己\n    // 然后触发属性的 getter 添加监听\n    // 最后将 Dep.target 置空\n    Dep.target = this\n    this.cb = cb\n    this.obj = obj\n    this.key = key\n    this.value = obj[key]\n    Dep.target = null\n  }\n  update() {\n    // 获得新值\n    this.value = this.obj[this.key]\n    // 调用 update 方法更新 Dom\n    this.cb(this.value)\n  }\n}\n")])])]),n("p",[e._v("以上就是 Watcher 的简单实现，在执行构造函数的时候将 Dep.target 指向自身，从而使得收集到了对应的 Watcher，在派发更新的时候取出对应的 Watcher 然后执行 update 函数。\n测试")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("var data = { name: 'yck' }\nobserve(data)\nfunction update(value) {\n  document.querySelector('div').innerText = value\n}\n// 模拟解析到 `"+e._s(e.name)+"` 触发的操作\nnew Watcher(data, 'name', update)\n// update Dom innerText\ndata.name = 'yyy' ")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);