(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{240:function(e,n,t){"use strict";t.r(n);var s=t(0),r=Object(s.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"实现小型打包工具"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现小型打包工具"}},[e._v("#")]),e._v(" 实现小型打包工具")]),e._v(" "),t("p",[e._v("因为涉及到 ES6 转 ES5，所以我们首先需要安装一些 Babel 相关的工具")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("npm i babylon babel-traverse babel-core babel-preset-env  \n")])])]),t("p",[e._v("接下来我们将这些工具引入文件中")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("const fs = require('fs')\nconst path = require('path')\nconst babylon = require('babylon')\nconst traverse = require('babel-traverse').default\nconst { transformFromAst } = require('babel-core')\n")])])]),t("p",[e._v("首先实现个读取文件的方法，通过babel将传入的文件es6转es5，并且将这个文件的依赖给获取到")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("function readCode(filePath) {\n  // 读取文件内容\n  const content = fs.readFileSync(filePath, 'utf-8')\n  // 生成 AST\n  const ast = babylon.parse(content, {\n    sourceType: 'module'\n  })\n  // 寻找当前文件的依赖关系\n  const dependencies = []\n  traverse(ast, {\n    ImportDeclaration: ({ node }) => {\n      dependencies.push(node.source.value)\n    }\n  })\n  // 通过 AST 将代码转为 ES5\n  const { code } = transformFromAst(ast, null, {\n    presets: ['env']\n  })\n  return {\n    filePath,\n    dependencies,\n    code\n  }\n}\n")])])]),t("p",[e._v("再实现个getDependencies函数，用来调用readCode，并接收入口文件，区分js和css，函数返回所有的依赖集合")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("function getDependencies(entry) {\n  // 读取入口文件\n  const entryObject = readCode(entry)\n  const dependencies = [entryObject]\n  // 遍历所有文件依赖关系\n  for (const asset of dependencies) {\n    // 获得文件目录\n    const dirname = path.dirname(asset.filePath)\n    // 遍历当前文件依赖关系\n    asset.dependencies.forEach(relativePath => {\n      // 获得绝对路径\n      const absolutePath = path.join(dirname, relativePath)\n      // CSS 文件逻辑就是将代码插入到 `style` 标签中\n      if (/\\.css$/.test(absolutePath)) {\n        const content = fs.readFileSync(absolutePath, 'utf-8')\n        const code = `\n          const style = document.createElement('style')\n          style.innerText = ${JSON.stringify(content).replace(/\\\\r\\\\n/g, '')}\n          document.head.appendChild(style)\n        `\n        dependencies.push({\n          filePath: absolutePath,\n          relativePath,\n          dependencies: [],\n          code\n        })\n      } else {\n        // JS 代码需要继续查找是否有依赖关系\n        const child = readCode(absolutePath)\n        child.relativePath = relativePath\n        dependencies.push(child)\n      }\n    })\n  }\n  return dependencies\n}\n")])])]),t("p",[e._v("现在我们已经获取到了所有的依赖文件，接下来就是实现打包的功能了")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("function bundle(dependencies, entry) {\n  let modules = ''\n  // 构建函数参数，生成的结构为\n  // { './entry.js': function(module, exports, require) { 代码 } }\n  dependencies.forEach(dep => {\n    const filePath = dep.relativePath || entry\n    modules += `'${filePath}': (\n      function (module, exports, require) { ${dep.code} }\n    ),`\n  })\n  // 构建 require 函数，目的是为了获取模块暴露出来的内容\n  const result = `\n    (function(modules) {\n      function require(id) {\n        const module = { exports : {} }\n        modules[id](module, module.exports, require)\n        return module.exports\n      }\n      require('${entry}')\n    })({${modules}})\n  `\n  // 当生成的内容写入到文件中\n  fs.writeFileSync('./bundle.js', result)\n}\n")])])]),t("p",[e._v("bundle函数就会输出打包后浏览器加载的样子了，一般会是下面")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(";(function(modules) {\n  function require(id) {\n    // 构造一个 CommonJS 导出代码\n    const module = { exports: {} }\n    // 去参数中获取文件对应的函数并执行\n    modules[id](module, module.exports, require)\n    return module.exports\n  }\n  require('./entry.js')\n})({\n  './entry.js': function(module, exports, require) {\n    // 这里继续通过构造的 require 去找到 a.js 文件对应的函数\n    var _a = require('./a.js')\n    console.log(_a2.default)\n  },\n  './a.js': function(module, exports, require) {\n    var a = 1\n    // 将 require 函数中的变量 module 变成了这样的结构\n    // module.exports = 1\n    // 这样就能在外部取到导出的内容了\n    exports.default = a\n  }\n  // 省略\n})\n")])])]),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),t("p",[e._v("webpack的核心步骤就是")]),e._v(" "),t("ol",[t("li",[e._v("找出入口文件所有的依赖关系")]),e._v(" "),t("li",[e._v("然后通过构建 CommonJS 代码来获取 exports 导出的内容\n从入口文件开始一层层遍历将依赖扁平化，然后通过js代码实现commonjs规范的module、exports、 require，让浏览器能成功运行。")])])])}),[],!1,null,null,null);n.default=r.exports}}]);