(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{211:function(t,a,s){"use strict";s.r(a);var r=s(0),n=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"web单张大图浏览缓慢问题解决"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#web单张大图浏览缓慢问题解决"}},[t._v("#")]),t._v(" Web单张大图浏览缓慢问题解决")]),t._v(" "),s("h3",{attrs:{id:"问题描述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#问题描述"}},[t._v("#")]),t._v(" 问题描述")]),t._v(" "),s("p",[t._v("在地铁项目中，现场提供的室内示意图有几十兆大小，直接加载示意图缓慢，web端体验很差。")]),t._v(" "),s("p",[t._v("地铁项目很有多张示意图，可能随时添加多张示意图，整个工作流程必须自动化的处理图片加载。")]),t._v(" "),s("h3",{attrs:{id:"解决方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[t._v("#")]),t._v(" 解决方案")]),t._v(" "),s("p",[t._v("首先解决加载单张大图加载缓慢的问题，可以使用切割工具，把图片切割成256×256的一块块图片。小图片的加载速度是很快的，按需加载即可。")]),t._v(" "),s("p",[t._v("其次，需要自动化，那么大体实现自动化的流程是：上传图片--后台切图--保存切图参数--加载切图参数和地图。")]),t._v(" "),s("p",[t._v("上传图片：即把大图片上传至后台准备处理，这里没有处理难度。")]),t._v(" "),s("p",[t._v("后台切图：需要把大图片切成一块块的图片，切割图片的工具有GMapImageCutter工具，可以把图片切割成金字塔的模式，方便放大浏览图片。GMapImageCutter工具是jar包的，需要手动调用，但这样不能满足自动化的使用，需要把对应的工具移动到java后台进行处理，而非手动调用。所以把其jar包反编译，提取有用的代码用在自己的java后台非常有必要。\n"),s("img",{attrs:{src:"https://s1.ax1x.com/2020/08/12/avO7tJ.jpg",alt:"avO7tJ.jpg"}}),t._v("\n保存切图参数：图片切好后，保存对应的url路径，并发布出来，用于使用，在这里比较简单不做描述。\n"),s("img",{attrs:{src:"https://s1.ax1x.com/2020/08/12/avOTk4.jpg",alt:"avOTk4.jpg"}}),t._v("\n加载切图参数和地图：当加载此图时，获得对应的url路径，解析切片，拼成一张图，这里使用openlayers js加载切片，可以方便解析GMapImageCutter切成的googlemap tile格式图片。\n第一级有一张图片，命名为t；")]),t._v(" "),s("p",[t._v("第二级有4张图片，命名为")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("tq,tr,\n\ntt,ts\n")])])]),s("p",[t._v("第三级有16张图片，命名为")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("tqq，tqr，trq，trr\n\ntqt，tqs，trt，trs\n\nttq，ttr，tsq，tsr\n\nttt，tts，tst，tss\n")])])]),s("p",[t._v("通过上面三级，可以发现第N层共有（4的N-1次方）张图片，首字符带t，每个位置的图片在下一级解析为q，r ，t，s。比如ttr图片命名，由于处于第三级则名字需要三个for循环确认，第一个字符来自于第一级t，第二个字符来自于第二级对应的tt图片，而第三个字符r处于四个图片的位置的右上用r来表示。大体的算法解析是")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v('var f=’t’;//起始第一级名称\n\nvar tileZ=2;//第三级的下标\n\nvar c=Math.pow(2,tileZ);//上一级有4张图片\n\nvar d=tileX;//对应传递过来的x位置\n\nvar e=tileY;//对应传递过来的y位置\n\nfor(var g=0;g<tileZ;g++){\n\n        c=c/2;\n\n        if(e<c){\n\n            if(d<c){f+="q"}//左上角\n\n            else{f+="r";d-=c}//右上角\n\n        }\n\n        else{\n\n            if(d<c){f+="t";e-=c}//左下角\n\n            else{f+="s";d-=c;e-=c}//右下角\n\n        }\n\n}\n')])])]),s("p",[t._v("通过算法解析，正确加载第三级图片，对应的解析路径\n"),s("img",{attrs:{src:"https://s1.ax1x.com/2020/08/12/avOHh9.jpg",alt:"avOHh9.jpg"}})]),t._v(" "),s("h3",{attrs:{id:"经验总结、预防措施和对规范的建议等"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#经验总结、预防措施和对规范的建议等"}},[t._v("#")]),t._v(" 经验总结、预防措施和对规范的建议等")]),t._v(" "),s("p",[t._v("本方案解决了单张大图在web上加载缓慢的问题，从自动切图到自动解析的过程，这种过程类似于切片缓存，用户可以设置切片的层级数，切片可以直接生成到http发布的路径，层级和url保存至数据库，加载时读取即可")])])}),[],!1,null,null,null);a.default=n.exports}}]);