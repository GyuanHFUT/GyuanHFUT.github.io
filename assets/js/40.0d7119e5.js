(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{242:function(e,r,a){"use strict";a.r(r);var v=a(0),s=Object(v.a)({},(function(){var e=this,r=e.$createElement,a=e._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"浏览器缓存位置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存位置"}},[e._v("#")]),e._v(" 浏览器缓存位置")]),e._v(" "),a("p",[e._v("缓存可以说是性能优化中简单高效的一种优化方式了，它可以显著减少网络传输所带来的损耗。")]),e._v(" "),a("p",[e._v("对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。")]),e._v(" "),a("p",[e._v("从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络")]),e._v(" "),a("ul",[a("li",[e._v("Service Worker")]),e._v(" "),a("li",[e._v("Memory Cache")]),e._v(" "),a("li",[e._v("Disk Cache")]),e._v(" "),a("li",[e._v("Push Cache")]),e._v(" "),a("li",[e._v("网络请求")])]),e._v(" "),a("h2",{attrs:{id:"service-worker"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#service-worker"}},[e._v("#")]),e._v(" Service Worker")]),e._v(" "),a("p",[e._v("Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。")]),e._v(" "),a("p",[e._v("当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。")]),e._v(" "),a("h2",{attrs:{id:"memory-cache"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#memory-cache"}},[e._v("#")]),e._v(" Memory Cache")]),e._v(" "),a("p",[e._v("Memory Cache 也就是内存中的缓存，读取内存中的数据肯定比磁盘快。但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。")]),e._v(" "),a("p",[e._v("当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存,内存容量很小，浏览器有自己的机制取存放")]),e._v(" "),a("ul",[a("li",[e._v("对于大文件来说，大概率是不存储在内存中的，反之优先")]),e._v(" "),a("li",[e._v("当前系统内存使用率高的话，文件优先存储进硬盘")])]),e._v(" "),a("h2",{attrs:{id:"disk-cache"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#disk-cache"}},[e._v("#")]),e._v(" Disk Cache")]),e._v(" "),a("p",[e._v("Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。")]),e._v(" "),a("p",[e._v("在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。")]),e._v(" "),a("h2",{attrs:{id:"push-cache"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#push-cache"}},[e._v("#")]),e._v(" Push Cache")]),e._v(" "),a("p",[e._v("Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。")]),e._v(" "),a("h2",{attrs:{id:"网络请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#网络请求"}},[e._v("#")]),e._v(" 网络请求")]),e._v(" "),a("p",[e._v("如果所有缓存都没有命中的话，那么只能发起请求来获取资源了。")]),e._v(" "),a("p",[e._v("那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，接下来我们就来学习缓存策略这部分的内容。")])])}),[],!1,null,null,null);r.default=s.exports}}]);